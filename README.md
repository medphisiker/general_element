# Главный элемент

## Описание

Эта задача с `All cups` ([ссылка](https://cups.online/ru/workareas/education_2277/1240/2397/)).

На `LeetCode` есть более простой вариант этой задачи ([ссылка](https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150)).

Решение задачи с LeetCode представлено тут ([ссылка](https://github.com/medphisiker/majority_element)).

Дан массив целых чисел. Ваша задача — определить, существует ли элемент, который встречается больше половины раз в массиве. Если такой элемент существует, вернуть его. Если такого элемента нет, вернуть `-1`.

## Формат входных данных

- В первой строке задаётся число `N` — размер массива (количество элементов).
- Во второй строке вводится массив из `N` целых чисел, разделённых пробелами.

## Формат выходных данных

Программа должна вывести:
- Элемент массива, который встречается больше половины раз
- `-1`, если такого элемента нет

## Пример 1

**Входные данные:**
```
7
7 7 8 8 8 8 9
```

**Выходные данные:**
```
8
```

## Подходы к решению

### Подход 1: Использование словаря для подсчёта частот

#### Описание
Этот подход заключается в том, чтобы пройти по массиву и подсчитывать количество вхождений каждого элемента с помощью словаря (хеш-таблицы). После каждого обновления счётчика проверяем, не превышает ли его количество половину длины массива. Если превышает, то сразу возвращаем этот элемент. Если после прохода по всему массиву такой элемент не найден, возвращаем `-1`.

#### Реализация

Смотри файл `solution.py`.

#### Сложность
- **Временная сложность:** O(n) — один проход по массиву
- **Пространственная сложность:** O(n) — в худшем случае храним счётчики для всех уникальных элементов

#### Нюансы
- ✅ **Простота:** Очень легко понять и реализовать
- ✅ **Надёжность:** Гарантированно находит решение, если оно существует
- ❌ **Память:** Требует O(n) дополнительной памяти
- ❌ **Производительность:** Для больших массивов может быть неэффективен из-за накладных расходов на хеш-таблицу

### Подход 2: Алгоритм Бойера-Мура (Boyer-Moore Majority Vote)

#### Описание
Элегантный алгоритм для поиска majority элемента за линейное время и с константной памятью. 

Состоит из двух этапов:
1. **Поиск кандидата:** Проходим по массиву, поддерживая текущего кандидата и счётчик. Если счётчик становится нулевым, выбираем нового кандидата.
2. **Проверка кандидата:** Вторым проходом проверяем, действительно ли кандидат встречается больше половины раз.

#### Реализация

Смотри файл `solution2.py`.

#### Сложность
- **Временная сложность:** O(n) — два прохода по массиву
- **Пространственная сложность:** O(1) — используем только несколько переменных

#### Нюансы
- ✅ **Экономия памяти:** Не требует хранения счётчиков для всех элементов
- ✅ **Производительность:** Эффективен для очень больших массивов
- ❌ **Сложность:** Чуть сложнее для понимания и реализации
- ❌ **Важность проверки:** Кандидат может быть найден даже если majority элемента нет (обязательна проверка)

## Сравнение подходов

| Критерий             | Подход 1 (словарь)       | Подход 2 (Бойер-Мур)      |
|----------------------|--------------------------|---------------------------|
| Временная сложность  | O(n)                     | O(n)                      |
| Пространственная сложность | O(n)               | O(1)                      |
| Простота реализации  | Очень просто             | Чуть сложнее              |
| Надёжность           | Высокая                  | Высокая (при проверке)    |
| Подходит для         | Маленьких массивов, простота | Большие массивы, экономия памяти |
| Лучше использовать   | Когда важна скорость разработки | Когда важна оптимизация по памяти |

## Рекомендации по выбору подхода

### Когда использовать Подход 1 (словарь):
- Для небольших массивов (до 10^5 элементов)
- Когда количество уникальных элементов невелико
- Если важна максимальная читаемость кода

### Когда использовать Подход 2 (Бойер-Мур):
- На олимпиадах по программированию
- Для очень больших массивов (более 10^6 элементов)
- При жёстких ограничениях по памяти

## Тестирование

Для проверки корректности обоих подходов реализован набор тестов в файле `test.py`, который покрывает:
- Нечётную длину массива с majority элементом
- Чётную длину массива с majority элементом
- Отсутствие majority элемента
- Массив из одного элемента
- Пустой массив
- Массив с отрицательными числами
- Все элементы одинаковые
- Граничный случай: majority ровно `n/2 + 1`

Тесты можно запустить командой:
```bash
python test.py
```

## Дополнительные материалы

- [Boyer-Moore Majority Vote Algorithm на Wikipedia](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)
- [Визуализация алгоритма Бойера-Мура](https://www.cs.utexas.edu/~moore/best-ideas/mjrty/)
- [Сравнение подходов к поиску majority элемента](https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/)
